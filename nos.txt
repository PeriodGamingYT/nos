(Based on James Molloy).
Package managment is handled at the kernel level.
The shell is a dynamic language enviorment (Proper one, no terminal/shell buisness).
Everything will use a universal text format (Something like HTML).
Each command will have a changing interactive foramtted text output.
Shell looks like:

1: Text editor # | 2: Listed Files 
file("/").list()

The shell has tabs, (mostly) each one being a output, and the first being a text editor (Ctrl-Enter to run text).
Ctrl+W - Close Tab (Closing text editor shuts down computer).
Ctrl+Tab - Switch tab.
Ctrl+Shift+Tab - Switch tab (Backwards).
Text editor shortcuts are standard text editor shortcuts.
Every file, package, output, and process has a UUID, that has meta-data attributes.
There should be a package repo where every package has an ID.
Half of all package ID's are private (unique on every system, can't be published) for development purposes.
How is configuration going to work? TODO
The only permissions are admin and non-admin permissions.
Programs are given admin and non-admin permissions
	If a program is non-admin it can:
		Access user directories.
		Access it's own package directory (Maybe config can be in there?).

Every program is a package.
Filesystem looks like
	usr
		a
			(user stuff)

		b
			(user stuff)

	pkg
		sum
			manifest (Configs can maybe go in here?)
			out/
				(stuff the whole system can read, but only the package can write)

processes
	VM? (Use some kind of bytecode for programs, this would remove the
	need for a userland, that is, if it's completely secure). Also cross
	platform binaries wouldn't be needed. As this VM would be implemented
	directly in the kernel. Thoughts?

bytecode
	There are 256 n byte arrays the program has immediate access to, think registers.
	n? Yes, the array can be resized to fit larger data types, but at the cost of having less "registers".
	Consequentially, "registers" will be combined, be wary of this.
	instructions (instruction (opcode): operands)
		load (0x00): register, 4 byte value
		push (0x01): register
		pop (0x02): register
		add (0x03): register, register
		sub (0x04): register, register
		mul (0x05): register, register
		div (0x06): register, register		
		jump (0x07): 4 byte number address
		compare (0x08): register, register
		set (0x09): register, n byte value
		jump_equal(0x10): 4 byte number address
		jump_zero(0x11): 4 byte number address
		jump_a_larger(0x12): 4 byte number address
		jump_carry(0x13): 4 byte number address
		jump_overflow(0x14): 4 byte number address
		stop(0x15): (none)
		mode(0x16): 1 byte

	notes about instruction set
		jump_not_x can be implemented like this (equal in this example)
			n - 2: compare
			n - 1: jump_equal x
			n: jump y
			x: ...
			y: ...

		mode will resize registers to be n^2 bytes, as an example
			0: set 0 255
			1: set 1 255
			2: mode 1
			3: add 0 1

			this won't work as expected, because there registers 1 and 0 are now combined together.
			so in this mode register 0 is now 510, but register 1 is now 0. switching back to mode 
			0 will make register 0 255 and register 1 255

			this example, however, will work:
			0: set 0 255
			1: set 2 255
			2: mode 1
			3: add 0 1

			even though this will work, it is discouraged, instead do this:
			0: mode 1
			1: set 0 255
			2: set 1 255
			3: add 0 1

			this one functions the same as the above, but it is easier to read. 
